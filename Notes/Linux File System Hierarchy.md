# Linux File System Hierarchy 
[If you don't want to read the Linux Filesystem Hierarchy bullshit below,  TLDR here](https://usernad8520.github.io/Linux-Notes/)


The Filesystem Hierarchy Standard

> This standard consists of a set of requirements and guidelines for file and directory placement under UNIX-like operating systems. The guidelines are intended to support interoperability of applications, system administration tools, development tools, and scripts as well as greater uniformity of documentation for these systems.

Unix-like operating systems refers to operating systems that have inherited features and design principals from one of the original Unix OSs. Generally this means Linux distros, BSD distros, MacOS, Haiku... We are going to focus on Linux.

```
/
├── bin -> usr/bin
├── boot
├── dev
├── etc
├── home
├── lib -> usr/lib
├── lib64 -> usr/lib64
├── lost+found
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin -> usr/sbin
├── srv
├── sys
├── tmp
├── usr
└── var
```

## `/`

The single `/` is the **root**. This is the outermost container; everything else on the system lives inside this directory.

## `/etc`

This directory contains system wide configuration. This has things like configuration for users on the system, SSH, and `apt`. This directory typically contains **text files**, **NOT PROGRAMS!**.

## `/home`

- This is where regular users store their personal files (documents, settings). The text compares this to an apartment building where every user has their own unit. 
  - If there are users "raj" and "aki" on a system the directories `/home/raj` and `/home/aki` will also exist. 

## `/usr`

- Despite the name, `/usr` does **not** contain user home directories.  
  - Instead, it contains the majority of **userland software**: *programs*, *libraries*, and *shared data* that are not required for early system boot.

- Historically, `/usr` stood for *Unix System Resources* and was often mounted read-only.

## `/usr/bin` and `/bin`

- These directories contain **executable programs (commands)**. This is where most of the programs we are going to use are located 
- On most modern systems, `/bin` is actually a symbolic link to `/usr/bin`. 

## `/usr/sbin` and `/sbin`

- These directories contain **system administration binaries**.

- These commands are typically intended for administrators (root), not regular users.

- As with `/bin`, many modern systems merge these directories internally. `/sbin` is a symbolic link to `/usr/sbin`

## `/usr/local/bin`

- This directory is for **locally installed software**—programs installed by the system administrator rather than the operating system’s package manager.

- Examples include:

  - Software compiled from source

  - Custom scripts

  - Tools installed manually


- Putting software here prevents it from **conflicting with system-managed files** in `/usr/bin`.

## `/var`

- Unlike the software directories (which stay mostly static), this directory contains files that change constantly, such as system logs, caches, and print queues

- Common subdirectories include:

  - `/var/log` — system and application logs

  - `/var/cache` — cached data

  - `/var/spool` — queued tasks (mail, printing)

  - `/var/lib` — application state data


## `/dev`

- This directory contains **device files**.

- Hardware devices (and some virtual devices) are represented as files here, such as:

  - `/dev/sda` — disks

  - `/dev/tty` — terminals

  - `/dev/null` — the “bit bucket”


- Interacting with hardware in Unix often means reading from or writing to files in `/dev`.

## `/proc`

- This is a  **pseudo filesystem or virtual filesystem** that provides information about the running system and processes.

- Files here do not exist on disk; they are generated by the kernel on demand.

- If you `cd` into proc and run `ls` you will see a bunch of directories named using numbers. Each of these is a process ID of a running process. 

- Examples:

  - `/proc/cpuinfo` — CPU details

  - `/proc/meminfo` — memory usage

  - `/proc/<pid>/` — information about a specific process


- `/proc` is a key interface for inspecting and tuning the running system.

### Pseudo Filesystems

- A **pseudo filesystem** is a filesystem that does **not** store data on a physical disk.  
  - Instead, it is created and maintained by the **kernel** and exists only in memory.

- Files and directories in a pseudo filesystem represent **system information, kernel data structures, or control interfaces**, not real files.

- You can interact with them using normal file tools (`ls`, `cat`, `echo`), but reading or writing these “files” actually triggers kernel behavior.

#### Why Pseudo Filesystems Matter

- They allow programs to inspect, configure, and control the system using standard file operations instead of special APIs.

- Without pseudo filesystems, modern Linux system management would be far more complex.

#### Quick Summary

| Filesystem | Purpose                         |
| ---------- | ------------------------------- |
| `/proc`    | Process & kernel information    |
| `/sys`     | Hardware & device configuration |
| `/dev`     | Device interfaces               |
| `/run`     | Runtime system state            |

## Symbolic Links (Symlinks)

A **symbolic link** (or **symlink**) is a special type of file that points to another file or directory by **path**, rather than containing the data itself.

You can think of a symlink as a **shortcut** or **reference** to another location in the filesystem.
### How Symbolic Links Work

- A symlink stores the path to its target
- When accessed, the system transparently follows the link
- If the target is removed or moved, the symlink becomes **broken**
- Symlinks can cross filesystem boundaries
- Symlinks can point to files *or* directories

### Visualizing Symbolic Links with `ls`

Using `ls -l` shows symbolic links clearly:

    lrwxrwxrwx 1 root root   11 Jan 10 12:00 editor -> /usr/bin/vim

Key things to notice:
- The first character is `l`, indicating a symbolic link
- The arrow (`->`) shows the target path
- Permissions on symlinks are usually shown as `rwxrwxrwx`, but are not meaningful

You can also use:
- `ls -l /bin` — to see symlinks on systems where `/bin` points into `/usr/bin`
### Creating Symbolic Links with `ln`

To create a symbolic link, use the `-s` flag:

    ln -s TARGET LINK_NAME

Example:

    ln -s /usr/bin/python3 python

This creates a symlink named `python` in the current directory that points to `/usr/bin/python3`.

### Common Uses of Symlinks

- Linking merged directories (e.g. `/bin` → `/usr/bin`)
- Providing alternate command names
- Managing versions of software
- Simplifying long paths
- Redirecting configuration or data locations


## Getting help

There is a man page for the filesystem hierarchy standard. `man hier`.





# Pipes (`|`) in Bash

The **pipe operator** (`|`) connects the output of one command directly into the input of another command.

Instead of sending output to the screen, a pipe sends it to the **next command** in the pipeline.

This allows you to build powerful command chains by combining small, focused tools.

## How Pipes Work

- The command on the **left** writes to standard output (stdout)
- The command on the **right** reads from standard input (stdin)
- Data flows **left → right**
- Each command runs concurrently

Conceptually:
- `command1 | command2 | command3`
## Simple Example

    ls | wc -l

- `ls` lists files
- `wc -l` counts lines
- Result: number of files in the directory

`ls` never prints to the terminal — its output goes directly into `wc`.

## Filtering Output

    ps aux | grep root

- `ps aux` lists running processes
- `grep root` filters lines containing “root”

This is a common pattern: **produce → filter → consume**.

## Transforming Data

    cat access.log | sort | uniq -c | sort -nr

Pipeline breakdown:
- `cat` outputs the file
- `sort` orders lines
- `uniq -c` counts duplicates
- `sort -nr` sorts numerically, descending

Each command does one simple job well.

## Using Pipes with `less`

    dmesg | less

This lets you scroll through long output interactively.





# Redirection in Bash

**Redirection** controls where a command’s input comes from and where its output goes.

Instead of reading from the keyboard or writing to the terminal, you can redirect data to or from **files** or other streams.

## File Descriptors (FDs)

Every process has numbered **file descriptors** representing open streams:

| FD   | Name   | Description                           |
| ---- | ------ | ------------------------------------- |
| `0`  | stdin  | Standard input (keyboard by default)  |
| `1`  | stdout | Standard output (terminal by default) |
| `2`  | stderr | Standard error (terminal by default)  |

Redirection works by changing where these file descriptors point.

## Redirecting Standard Output (stdout)

### Write stdout to a file

This will create the file if doesn't already exist. If it does exist this will overwrite the file.
```bash
ls > files.txt
```

### Append stdout to a file
```bash
ls >> files.txt
```
## Redirecting Standard Error (stderr)

### Write stderr to a file
```bash
ls /does/not/exist 2> errors.txt
```
The error message is written to `errors.txt`, not the terminal.

### Append stderr to a file
```bash
command 2>> errors.txt
```

## Redirecting Both stdout and stderr

### Redirect both to the same file

```bash
command > output.txt 2>&1
```

This means:
- stdout → `output.txt`
- stderr → wherever stdout is currently going

Order matters.

### Shorthand (Bash-specific)

```bash
command &> output.txt
```

Append version:

```bash
command &>> output.txt
```

### Read input from a file

```bash
wc -l < files.txt
```

The file is fed into the command as if typed at the keyboard.

### Discarding errors

Send output to `/dev/null`
```bash
command 2> /dev/null
```





# Getting Started with Vim

## What is Vim?

[Vim](https://www.vim.org) is a Modal text editor. You can use it to edit plain text documents, like Python scripts. Similar to VSCode.

Vim has a steeper learning curve than VSCode, but it is worth learning. Vim keybindings are everywhere! Once you get the hang of using Vim and Vim keybindings you may find that you want to use them in all of the places.

Vim was created by Bram Moolenaar and originally released in 1992.
### Vim and Neovim

If you have been looking into Vim on your own you may have encountered [Neovim](https://neovim.io). Currently there are two actively maintained versions of Vim, Vim and Neovim.

We are going to use Vim in the class, it comes installed on our servers. But if you want to try out Neovim, feel free to install it on your laptop. Both Vim and Neovim are available for Linux, MacOS and Windows.
### What is a modal editor?

Vim has different "modes". In these different modes key presses will do different things. 

For example the "c" key in Normal mode is used to change text. 

Assume you have the following in a file open in Vim.
```
[ "this is some text" ]
```

If your cursor is somewhere between the `[]` and you press `ci[` in normal mode. You will delete all of the text inside of the brackets and enter insert mode. 
- c = change
- i = inside (waits for an object, like brackets or quotes)
- `[` = the object pair you want to use to delimit your changes.

There are other modal editors, like [Helix](https://helix-editor.com).
## Learning Vim

The best way to learn Vim is to use it to write plain text documents (code). Try using Vim to do your Python home work. 

Have Vim open in your VM and try things out as you go through the document below.

Don't try to learn all of Vim at once. Try incorporating new commands as you go. Start with the basics. After you have the basic down, try incorporating new things (commands, plugins...) as you need them. 
## Opening vim

To open, or start vim just type `vim` and press enter.

To open a file in Vim, type `vim <file-name>`. If the file doesn't exist this will create a new file.

You can also open files in a Vim session with commands `:e` and `:find`. There are other ways to do this as well. Vim is very flexible, so there are usually multiple ways to do things.
## Vim modes

### Normal mode

Normal mode is the default in Vim. When you first open Vim, or open a file in Vim you are in Normal mode.

This is one of the things that makes Vim tricky for new users. But for professional software developers this makes the most sense.  A professional software developer will spend considerably more time working on an existing code base (searching, editing files) then they will on new empty documents. 

Normal mode is where you will do most of your editing.

For example `yy` will copy the line the cursor is currently on. "y" for "yank". Think pulling text from the buffer into the register. `p` will paste text.
### Insert mode

To get to insert mode press "i" from Normal mode.
To return to Normal mode, press "escape".

Insert mode is probably the mode you are most familiar with. This is the only mode VSCode has. In insert mode you can enter text the way you are used to doing in most tools. "i" will write the character "i" where the cursor is.

When you are in Insert mode the bottom left corner of the screen will display "INSERT" like in the screenshot below

![Vim insert](../attach/ss-2026-01-12-16-28-03.png)

You can also enter Insert mode from Normal mode with
- "A" moves the cursor to the end of the current line and enters insert mode.
- "o" creates a new line below the current line and enters insert mdoe.
- "O" creates a new line above the current line and enters insert mode.
### Command mode

To enter command mode type `:` followed by a command and press "enter".
To exit command mode and return to normal mode press "escape"

Command mode allows you to enter commands like, quit the editor, save the file...

- save `:w` write buffer contents to file (when you open a file you are making a copy of that file in memory, this is called a buffer).
- quit `:q`
- save and quit `:wq`
- quit without saving changes made after last save `:q!`
- delete the entier document `:%d`

Just like Insert mode, your commands will show up in the bottom left corner of your Vim window.

### Visual mode

Visual mode is actually three different modes.
- Visual mode, select characters `v`
- Visual block mode, select rectangular blocks `ctrl+v`
- Visual line mode, select lines `shift+v`
- Press "escape" to return to Normal mode.

Visual mode allows you to visually select text in a buffer. After you have selected text you will probably want to perform some action on that text.
## Vim motions

One of the reasons that Vim is still so popular is Vim motions. In general Vim motions are designed to keep your hands on the keyboard.
There is a Vim cheatsheet below with more motions.



All of the motions below are done In normal mode

Move one character at a time
- h = left
- j = down
- k= up
- l = right
	- Notice that this keeps your right hand close to the home row.

Move by word
- `w` = move to first character in the next word 
- `b` = move to first character in the previous word (backwards by word)

Move to beginning/end of line
- `$` = end of the current line
- 0 = beginning of the current line

Move to beginning/end of the open buffer
- `gg` beginning of a buffer
- `G` end of a buffer

## Vim commands are composable

People often say that learning Vim is a little like learning a language. This is because Vim commands are composable, you combine nouns(Motions) with verbs(Operations) to perform more complex actions in a buffer.

You have already seen this in action with the change commands.


In Normal mode
`d` = delete.
- `dd` = delete the current line
- `dw` = delete to the end of a word
- 3dw = delete the next three words

## Searching for text in a Vim buffer

`/search-word` search forward(the next instance of the pattern in your buffer). Press enter to search for your pattern.
Pressing `n` will take you to the next search match and `N` will take you to the previous.

For example if I want to find the next instance of the word "cat", `/cat` and press enter, from normal mode.

`?` searches backwards. When you searching backwards `n` moves backwards, and `N` moves forwards.

This is also how you search for text in `less`, the pager the man pages open in.

## The really important bits

Make sure you know how to do the following:
- open an existing file in Vim
- open a new file in Vim
- save a file in Vim
- quit Vim
- move between different modes so that you can open a file and make basic edits. 
	- Try not to go to insert mode and do everything in insert mode.





