# Bash Configuration & Package Management

---

## Understanding Bash Configuration Files

### What are Configuration Files and Why Do They Exist?

When you open a terminal in Linux you are starting a program called a **shell**. The shell is your CLI (command line interface) - it reads what you type, interprets it, and tells the OS what to do. **BASH** (Bourne Again SHell) is the most common shell on Linux systems.

But here's one thing: Every time you start a new terminal session, Bash starts fresh. It will not remember your preferences, shortcuts, or customizations before. This is where customization files come into play.

**Configuration files** are special text files that Bash will automatically read when it starts. Inside these configuration files contain instructions that help customize your shell environment such as:

- What your prompt looks like.
- Shortcut (aliases) for commands your use frequently.
- Where to find programs (your PATH).
- Environment variables that your program needs.

This matters because without these configuration files, you have to manually set up your preferred settings every time you open a terminal which is a hassle and time consuming. Configuration files make your customizations *persistent*, meaning they survive across sessions.

---

### Interactive vs. Non-Interactive Shells

Before understanding which configuration file does what, we need to know the how Bash can be started.

#### Interactive Shell

An **interactive shell** relies on the user to type a command to see the output. You see a prompt, you type something, you press Enter, and something happens.

**Examples of interactive shell:**
- Opening a terminal app on your desktop
- SSH-ing into a remote server.
- Running a `bash` from within another shell.

**Features enabled in interactive mode:**
- Command prompt ( the `$` or `#` you see)
- Command history
- Tab completion
- Job control (`ctrl+z` to suspend)

#### Non-Interactive Shell

A **non-interactive shell** runs without needing a user interaction. It executes commands from a script then exits.

**Examples:**

```bash
bash myscript.sh
```

This script runs, does its job, then the shell exits. No prompt and no waiting for input.

#### Why This Distinction Matters

Bash loads different config files depending if they are interactive or non-interactive. If you put your shortcuts into the wrong file, they will not be available when you need to use them.

---

### Login Shell vs. Non-Login Shell

There is also another distinction: **login** vs. **non-login** shells.

#### Login Shell

A login shell is the first shell that starts up when you log into a system. Its main purpose is setting up the entire environment.

**Examples:**
- SSH-ing into a server (this is a login shell)
- Logging in at a physical console.
- Using `su - username` (the `-` makes it a login shell)

#### Non-Login Shell

A non-login shell is shell started **after** your have already logged in, it uses the environment from its parent process. It doesn't need to set everything up from scratch.

**Examples:**
- Opening a new terminal tab
- Running `bash` from within an existing shell
- Running a script

---

### The Configuration Files Explained

Let's take a look at the actual files and when Bash reads them.

#### `/etc/profile` (System-Wide)

| Attribute | Description |
|-----------|-------------|
| **What is it** | A system wide configuration that applies to ALL users. |
| **When it's read** | When a user starts a login shell. |
| **Who edits it** | Sys Admins (requires root privileges) |
| **What are the contents here** | System-wide environment variables - PATH addons that should apply to everyone. |

> ⚠️ **Warning:** DO NOT edit this file unless your a sysadmin and know what you are doing. These changes effect all users.

#### `~/.bash_profile` and `~/.profile`

| Attribute | Description |
|-----------|-------------|
| **What they are** | User specific config files for **login shells** |
| **When they're read** | When the user starts a login shell (Like SSH-ing into a server) |

**The reading order:**
1. `/etc/profile` (system-wide, always first)
2. `~/.bash_profile` (if it exists, Bash stops here)
3. `~/.bash_login` (only if `~/.bash_profile` doesn't exist)
4. `~/.profile` (only if neither of the above exist)

Bash only needs ONE of these user files - the first one it finds. If you have a  `~/.bash_profile`, Bash will never read `~/.profile` during login.

**What contents goes here:**
- Environment Variables (like `EDITOR`, `LANG`)
- PATH modifications
- Anything that should be set once at login and inherited by all programs. 

**Example `~/.profile`:**

```bash
# Set default text editor
export EDITOR="nano"

# Add local bin directory to PATH
if [[ -d "$HOME/.local/bin" ]]; then
    PATH="$HOME/.local/bin:$PATH"
fi
```

#### `~/.bashrc`

| Attribute | Description |
|-----------|-------------|
| **What it is** | User config for interactive (non-login) shells. |
| **When it's read** | Every time you start an interactive non-login shell. |
| **What goes here** | Shortcuts (aliases), Shell functions, Prompt customizations |

**Example `~/.bashrc`:**

```bash
# Aliases
alias ll='ls -la'
alias gs='git status'

# Colorful prompt
PS1='\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\$ '
```

When you SSH into a server, you start a login shell. Login shells read `~/.profile` or `~/.bash_profile`, but NOT `~/.bashrc` by default!

**The solution:** Most people add this line to their `~/.bash_profile` or `~/.profile`:

```bash
# Source .bashrc if it exists
if [[ -f ~/.bashrc ]]; then
    source ~/.bashrc
fi
```

This ensures that your aliases (shortcuts) and prompt work even in login shells.

---

### Quick Reference: What goes Where?

| Setting Type | File | Why |
|--------------|------|-----|
| Environment variables (`EDITOR`, `LANG`) | `~/.profile` or `~/.bash_profile` | Set once at login, inherited by all programs |
| PATH modifications | `~/.profile` or `~/.bash_profile` | Programs need to find executables |
| Aliases | `~/.bashrc` | Only needed in interactive shells |
| Shell functions | `~/.bashrc` | Only needed in interactive shells |
| Prompt (PS1) | `~/.bashrc` | Only needed in interactive shells |

**Rule of Thumb:**
- **Affects all programs?** →  `~/.profile` or `~/.bash_profile`
- **Only affects your command line?** → `~/.bashrc`

---

### Applying Changes

After editing a config file, you need to remember that the changes dont take effect immediately. You have two options:

**Option 1: Source the file**

```bash
source ~/.bashrc
# or equivalently:
. ~/.bashrc
```

**What `source` does:** It reads and executes the file in your *current* shell. Changes take effect immediately. 

**Option 2: Start a new shell**

```bash
bash
```

or simply open a new terminal window/tab

---

## Customizing Your Bash Prompt

### What is the Prompt?

The **prompt** is the **text or symbol** that appears at the beginning of the line where you type your commands. It acts as a "waiting" indicator.

**Default Debian prompt:** `root@username:~#`

**Let's break this down:**
- `root`: the username (who you are logged in as)
- `@` separator (just decoration)
- `username`: the hostname(the computer's name)
- `:`: separator
- `~`: current directory (`~` means your home directory)
- `#`  indicates you're the root user (`$` for regular users)

---

### The PS1 Variable

The prompted is controlled by an **environment variable** called **`PS1`** (Prompt String 1)

| Attribute | Description |
|-----------|-------------|
| **Purpose** | Defines what the primary prompt looks like. |
| **Why it exists** | Because different users have different needs, for example, a developer might want to see Git branch info or a sysadmin might to see the hostname noticeably. PS1 allows you to customize this. |

**Viewing your current prompt:**

```bash
echo "$PS1"
```

**Sample output:** `\u@\h:\w\$`

- `\u`: represents username of person currently logged in
- `@`: symbol to separate the user and host
- `\h`: name of the computer or server (hostname)
- `:` a literal colon to separate the host from the location.
- `\w`: the working directory, the fill path of the folder you are in
- `\$`:  shows for regular users and `#` for root/admin

The backslash sequence are escape codes that Bash expands into actual value

**Changing Your Prompt Temporarily:**

```bash
PS1="> "
```

Now your prompt is just `>` . This change lasts only until you close the terminal.

---

### Prompt Escape Sequences

Bash provides special sequences that get replaced with dynamic information:

| Sequence | Meaning | Example Output |
|----------|---------|----------------|
| `\u` | Username | `alice` |
| `\h` | Hostname (short) | `laptop` |
| `\H` | Hostname (full) | `laptop.local` |
| `\w` | Current directory (full path, `~` for home) | `~/projects/myapp` |
| `\W` | Current directory (base name only) | `myapp` |
| `\$` | `$` for regular users, `#` for root | `$` |
| `\n` | Newline | (starts a new line) |
| `\t` | Time (24-hour HH:MM:SS) | `14:30:45` |
| `\d` | Date (Day Month Date) | `Mon Jan 15` |
| `\!` | History number of this command | `142` |

#### Practical Examples

**Simple username and directory:**

```bash
PS1="\u:\w \$ "
```

Result: `dan:~/projects $`

**Include hostname (useful when SSH-ing to multiple servers):**

```bash
PS1="\u@\h:\w \$ "
```

Result: `dan@webserver:~/projects $`

**Two-line prompt (for long paths):**

```bash
PS1="\u@\h:\w\n\$ "
```

Result: `dan@webserver:~/very/long/path/to/project $`

---

### Adding colors to Your Prompt

Colors in your prompt make it easier to read and can also highlight important information (like when you're root!).

#### How ANSI Color Codes Work

Colors use **ANSI escape sequences**. The format is: `\[\e[0;32m\]`

- `\[` and `\]`: These tell Bash that the color code has "zero width", so it doesn't mess up your cursor alignment.
- `\e[`: Starts the escape sequence.
- `0;32`: This is the actual color. `0` means normal text; `32`is the color green.
- `m`: Ends the color sequence.

**Text Colors:**

| Color | Code |
|-------|------|
| Black | 30 |
| Red | 31 |
| Green | 32 |
| Yellow | 33 |
| Blue | 34 |
| Magenta | 35 |
| Cyan | 36 |
| White | 37 |

**Bright Colors:** Add 60 (e.g., bright red = 91)

**Styles:**

| Style | Code |
|-------|------|
| Reset (normal) | 0 |
| Bold | 1 |
| Dim | 2 |
| Underline | 4 |

#### The Reset Code

> ⚠️ **Critical:** Always end your prompt with the reset code!

```bash
\[\e[0m\]
```

If you forget this, everything you type will be colored too.

#### Color Examples

**Green username, blue directory:**

```bash
PS1='\[\e[32m\]\u\[\e[0m\]@\h:\[\e[34m\]\w\[\e[0m\]\$ '
```

**Red prompt for root (warning!):**

```bash
PS1='\[\e[31m\]\u@\h:\w\$ \[\e[0m\]'
```

---

### Making Your Prompt Permanent

Adding your PS1 definition to `~/.bashrc`: 

```bash
# Add to ~/.bashrc
PS1='\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\$ '
```

Then reload:

```bash
source ~/.bashrc
```

---

### Other Prompt Variables

Bash actually has 5 prompt variables:

| Variable | When it's Shown |
|----------|-----------------|
| `PS0` | Appears **after** you hit Enter but **before** the command's result shows up. It is often used to display a timestamp or a "Processing..." message for long commands. |
| `PS1` | Primary prompt (the main one you customize). This is what you see every time the terminal is ready for a new command |
| `PS2` | Continuation prompt (when a command spans multiple lines), If you start a command but don't finish it, this prompt appears to show the command is still "continuing." |
| `PS3` | This is used specifically inside shell scripts when using the `select` command to create a menu. It asks the user to make a choice. |
| `PS4` | This is used when you are debugging a script (using `set -x` or `bash -x`). It appears before every line of code the script executes to help you track what's happening. |

#### Examples for each variable

**PS0:**

```bash
PS0='[Command started at \t]\n'
```

**What it looks like:**
```
dan@bcit-laptop:~$ sleep 2
[Command started at 14:30:05]
(2 second pause)
dan@bcit-laptop:~$
```

**PS1:**

```bash
PS1='\u@\h:\w\$ '
```

**What is looks like:** `dan@bcit-laptop:~/acit2420$`

**PS2:**

Default value: `>`

**What it looks like:**

```bash
dan@bcit-laptop:~$ echo "This is a very
> long sentence
> that spans multiple lines"
```

*(The `>` is the PS2 prompt).*

**PS3:**

```bash
select brand in Toyota Honda VW; do
  echo "You chose $brand"
  break
done
```

**What it looks like:**
```
1) Toyota
2) Honda
3) VW
#?
```

*(This `#?` is the PS3 prompt. You can change it to "Please pick: ")*

**PS4:**

Default value: `+`

**What it looks like:** If you run a script called `test.sh`:
```
+ echo 'Starting script'
Starting script
+ cp file.txt backup/
```

*(The `+` is the PS4 prompt).*

---

## Aliases and Shell Functions

### What are Aliases?

An **alias** is a shortcut (a short name) that expands into a longer name.

**Why they exist:** Typing the same long commands repeatedly is inefficient and error-prone. Aliases eliminates that threat by letting you create memorable shortcuts.

#### Creating an Alias

**Syntax:**

```bash 
alias name='command'
```

**Rules:**
- No spaces around the `=`
- Use quotes if the command contains spaces or special characters

#### Examples

**Example 1:**

```bash
alias ll='ls -la'
alias gs='git status'
alias update='sudo apt update && sudo apt upgrade'
```

Once defined, use them like regular commands:

**`dan@bcit:~$ ll`:**

```
drwxr-xr-x  5 dan dan  4096 Feb  2 16:30 .
drwxr-xr-x  3 root root  4096 Jan 12 10:00 ..
-rw-------  1 dan dan  1234 Feb  2 16:40 .bash_history
-rw-r--r--  1 dan dan   220 Jan 12 10:00 .bash_logout
-rw-r--r--  1 dan dan  3771 Jan 12 10:00 .bashrc
drwxr-xr-x  8 dan dan  4096 Feb  1 09:15 .git
-rw-r--r--  1 dan dan   807 Jan 12 10:00 .profile
drwxr-xr-x  2 dan dan  4096 Feb  2 15:00 labs
```

**`dan@bcit:~/acit2420$ gs`:**

```
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   lab1_script.sh

no changes added to commit (use "git add" and/or "git commit -a")
```

**`dan@bcit:~$ update`:**

```
[sudo] password for dan: 
Hit:1 http://archive.ubuntu.com/ubuntu jammy InRelease
Get:2 http://archive.ubuntu.com/ubuntu jammy-updates InRelease [119 kB]
...
Reading package lists... Done
Building dependency tree... Done
Calculating upgrade... Done
The following packages will be upgraded:
  curl libcurl4
2 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 412 kB of archives.
After this operation, 0 B of additional disk space will be used.
Do you want to continue? [Y/n]
```

**Example 2: Viewing All Aliases**

```bash
alias
```

**Example 3: Checking What an Alias Expands To**

```bash
type ll
```

Output: `ll is aliased to 'ls -la'`

**Example 4: Temporary bypassing an Alias**

If you've aliased a command but need the original command:

- **Method 1: Backslash**
  ```bash
  \ls
  ```

- **Method 2: Full Path**
  ```bash
  /bin/ls
  ```

- **Method 3: Remove alias**
  ```bash
  unalias ll
  ```

---

### Alias Limitations

Aliases are simple text substitution. They:

- **Replace** the alias name with the command text
- **Cannot** accept arguments in the middle
- **Cannot** contain logic (if/else)

**Example of what aliases CAN'T do:**

```bash
# This WON'T work as expected
alias greet='echo "Hello, $1"'
```

For anything more complex, you need **shell functions**.

---

### Shell Functions

A shell function is like a mini script that lives in your shell. Unlike aliases functions:

- Can accept arguments (`$1`, `$2`, etc.)
- Can contain logic (if/else, loops)
- Can have multiple commands
- Can return exit codes

**Basic Function Syntax:**

```bash
function_name() {
    commands
}
```

#### Practical Examples

**Example 1: Create a directory and cd into it:**

```bash
mkd() {
    mkdir -p "$1" && cd "$1"
}
```

**Usage:**

```bash
$ mkd new_project
$ pwd
/home/alice/new_project
```

**What's happening:**
- `$1` is the first argument you pass
- `mkdir -p` creates the directory (and parents if needed)
- `&&` means "if that succeeds, then..."
- `cd "$1"` changes into the new directory

**Example 2: Extract various archive formats:**

```bash
extract() {
    if [[ ! -f "$1" ]]; then
        echo "Error: '$1' is not a file"
        return 1
    fi

    case "$1" in
        *.tar.gz)  tar -xzf "$1" ;;
        *.tar.bz2) tar -xjf "$1" ;;
        *.tar)     tar -xf "$1" ;;
        *.zip)     unzip "$1" ;;
        *.gz)      gunzip "$1" ;;
        *)         echo "Unknown format: $1" ;;
    esac
}
```

**What is happening:**

**Safety Check:**

```bash
if [[ ! -f "$1" ]]; then
    echo "Error: '$1' is not a file"
    return 1
fi
```

- **`$1`**: This represents the first argument you type after the command (the filename).
- **`! -f`**: This checks if the file **does not** exist. If you type a folder name or a typo, it stops immediately and prints an error.

**The Logic (Case Statement):**

```bash
case "$1" in
    *.tar.gz)  tar -xzf "$1" ;;
    *.zip)     unzip "$1" ;;
    ...
    *)         echo "Unknown format: $1" ;;
esac
```

The `case` block looks at the **file extension** and runs the corresponding command:
- **`.tar.gz`**: Uses `tar` with `-x` (extract), `-z` (gzip), and `-f` (file).
- **`.zip`**: Uses the `unzip` utility.
- **`*)`**: This is the "catch-all" (default). If you try to extract something like a `.txt` or `.jpg`, it tells you it doesn't know how to handle it.

**Sample Output:**

| Case | Input | Output |
|------|-------|--------|
| Successful Extraction | `extract assignment.tar.gz` | *(No text output, but the command runs successfully. If you run `ls` afterward, you will see a new folder or files created from the archive.)* |
| File Not Found | `extract lab_notes.zip` | `Error: 'lab_notes.zip' is not a file` |
| Unsupported Format | `extract my_photo.png` | `Unknown format: my_photo.png` |

---

### Making Aliases and Functions Permanent

Add them to `~/.bashrc`:

```bash
# ~/.bashrc

# Aliases
alias ll='ls -la'
alias gs='git status'
alias ..='cd ..'
alias ...='cd ../..'

# Functions
mkd() {
    mkdir -p "$1" && cd "$1"
}
```

Reload:

```bash 
source ~/.bashrc
```

---

### Useful Alias Ideas

```bash
# Safety aliases (ask before overwriting)
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'

# Colorized output
alias ls='ls --color=auto'
alias grep='grep --color=auto'

# Quick navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ~='cd ~'

# Git shortcuts
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline'
```

> ⚠️ **Warning about `rm`:** Some people alias `rm` to `rm -i` (interactive mode). This is safer but can create a false sense of security. If you ever use a system without your aliases, you might accidentally delete files expecting a confirmation that never comes.

---

## The PATH Environment Variable

### What is PATH?

**PATH** is an environment variable that tells your shell where to look for executable programs.

When you type in the command like `ls`, your shell doesn't magically know where the `ls` program is located. It searches through a list of directories - that list is your **PATH**.

**Viewing your PATH:**

```bash
echo $PATH
```

**Sample output:** 

```bash
/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
```

The directories are separated by colons (`:`). The shell searches them **in order**, **left to right**.

---

### How PATH Works

When you type `ls`:

1. The shell checks: is `ls` in `/usr/local/bin`? NO.
2. Shell checks: is `ls` in `/usr/bin`? YES! Run it.

If the command is not found in any directory you get: `bash: somecommand: command not found`

---

### Adding a Directory to PATH

**Why would you do this?**
- You installed a software in a non standard location.
- You have personal scripts in `~/bin` or `~/.local/bin`
- A programming language installed tools in its own directory.

#### Temporary Addition (Current Session Only)

```bash
PATH="$HOME/.local/bin:$PATH"
```

**What this does:**
- Adds `~/.local/bin` to the FRONT of PATH
- Preserves the existing PATH (the `$PATH` at the end)

**Why add to the front?** Directories are searched left-to-right. Putting your directory first means your versions of programs take precedence.

#### Permanent Addition

Add to `~/.profile` or `~/.bash_profile`:

```bash
# Add .local/bin to PATH if it exists
if [[ -d "$HOME/.local/bin" ]]; then
    PATH="$HOME/.local/bin:$PATH"
fi
```

**What the `if` statement does:**
- `-d` tests if the directory exists
- Only adds to PATH if the directory is actually there
- Prevents errors and keeps PATH clean

---

### Common PATH Mistakes

**Mistake 1: Overwriting PATH entirely**

```bash
# WRONG - destroys your existing PATH!
PATH="/my/custom/bin"
```

Now you can't run basic commands like `ls` because `/usr/bin` is no longer in PATH!

**Correct:**

```bash
PATH="/my/custom/bin:$PATH"
```

**Mistake 2: Forgetting to export**

If you set PATH in a script and want child processes to see it:

```bash
export PATH="$HOME/bin:$PATH"
```

(In `.profile/.bash_profile`, `export` is usually not needed because these files are sourced, not executed.)

---

## Package Management with APT

### What is Package Manager?

A **package manager** is a tool that installs, updates, and removes software on your system.

**Why it exists:** In the early days of computing, installing software meant:

1. Finding the source code
2. Downloading it
3. Resolving dependencies (other software it needs)
4. Compiling it
5. Installing it to the right locations
6. Hoping nothing breaks

This was tedious and error-prone. Package managers automate all of this.

---

### Key Concepts

#### Packages

A **package** is a bundle containing:
- The software itself (complied programs or scripts)
- Metadata (version, description, author)
- Dependency information (what other packages it needs to run smoothly)
- Installation instructions (where the files go)

On Debian, packages use the `.deb` format

#### Repositories

A repository (or "repo") is a server hosting packages. Think of it like the app store, but for your entire operating system.

Debian's repos are organized into branches:
- **Stable** - rigorously tested, rarely changes. best for servers
- **Testing** - Newer packages being prepared for the stable.
- **Unstable (sid)** - prone to bugs, May break.  

#### Dependencies

A dependency is a software that another packages requires for it to run and function properly. For example, a Python application depends on Python being installed.

Package managers automatically resolve dependencies - If you install package A, and it needs package B and C, the package manager installs all three.  

---

### dpkg vs. APT

Debian has two levels of package management:

#### dpkg (Low-Level)

- Works with individual .deb files on your disk
- Does NOT resolve dependencies (manually install decencies one by one)
- Rarely used directly 

```bash
# Install a local .deb file
sudo dpkg -i package.deb
```

#### APT (High-Level)

- Reaches out to servers (repos) over the internet
- Automatically resolves dependencies 
- What you'll use 99% of the time.

---

### Essential APT Commands

#### Update Package Lists

```bash 
sudo apt update
```

**What it does:** Downloads and updates the latest package information from repos. **DOES NOT** install anything.

#### Install a package

```bash
sudo apt install package_name
```

**Example:**

```bash
sudo apt install notepad++
```

**What happens:**
1. APT checks if `notepad++` is in the package lists.
2. Identifies dependencies
3. Downloads `notepad++` and any missing dependencies
4. Installs everything
5. Configures the software

**Installing multiple packages:**

```bash
sudo apt install htop vim git
```

#### Upgrade Installed Packages

```bash
sudo apt upgrade
```

**What it does:** Upgrades all installed packages to their newest versions.

**Important:** This **WILL NOT** remove packages. If an upgrade requires removing something, it's skipped.

**For more aggressive upgrades:**

```bash
sudo apt full-upgrade
```

This WILL remove packages if necessary to complete the upgrade.

#### The Update + Upgrade Combo

```bash
sudo apt update && sudo apt upgrade
```

**What `&&` does:** Run the second command only if the first succeeds.

**Best practice:** Always update before upgrade to ensure you're getting the latest versions.

#### Remove a Package

```bash
sudo remove package_name
```

**What it does:** Removes the package but keeps configuration files.

**Why keep configs?** If you reinstall later, your settings are preserved.

**To remove everything including configs:**

```bash
sudo apt purge package_name
```

#### Clean Up Unused Packages

```bash
sudo apt autoremove
```

**What it does:** Removes packages that were installed as dependencies but are no longer needed.

**When this happens:** You install package A, which needs package B. Later you remove A, but B stays. `autoremove` cleans up B.

#### Search for Packages

```bash
apt search keyword
```

**Example:**

```bash
apt search text editor
```

Note: `search` doesn't require `sudo`.

#### Get Package Information

```bash
apt show package_name
```

**Example:**

```bash
apt show vim
```

Shows: description, version, dependencies, size, maintainer, etc.

#### List Manually Installed Packages

```bash
apt list --manual-installed
```

**What it shows:** Packages YOU explicitly installed (not dependencies).

---

### APT Command Reference

| Command | Description |
|---------|-------------|
| `apt update` | Refresh package lists from repositories |
| `apt upgrade` | Upgrade all packages (safe, no removals) |
| `apt full-upgrade` | Upgrade all packages (may remove some) |
| `apt install foo` | Install package "foo" |
| `apt remove foo` | Remove "foo" (keep config files) |
| `apt purge foo` | Remove "foo" and its config files |
| `apt autoremove` | Remove unneeded dependencies |
| `apt search regex` | Search for packages |
| `apt show foo` | Display package details |
| `apt list --manual-installed` | List manually installed packages |
| `apt clean` | Delete all cached package files |
| `apt autoclean` | Delete outdated cached package files |

---

### Warnings and Best Practices

> ⚠️ Always use sudo with APT commands that modify the system. Installing, removing, and upgrading packages requires root privileges.

> ⚠️ Update regularly. On testing/unstable branches, updates come frequently. Falling behind can make upgrades more complex.

> ⚠️ Read what APT tells you. Before confirming an install/upgrade, APT shows what will be installed, upgraded, or removed. Pay attention!

> ⚠️ Be careful with full-upgrade. It can remove packages. Make sure you understand what's being removed before confirming.

---

### Why apt vs apt-get?

| Tool | Description |
|------|-------------|
| `apt-get` | The older, traditional command. More options, designed for scripts. |
| `apt` | Newer, user-friendly. Combines features of apt-get and apt-cache. Has a progress bar. |

**For Interactive use:** Use `apt`. It's simpler and prettier.

**For scripts:** Use `apt-get`. Its output format is more stable across versions.

---

## Summary: Configuration File Cheat Sheet

```
┌─────────────────────────────────────────────────────────────┐  
│                    BASH STARTUP FILES                        │  
├─────────────────────────────────────────────────────────────┤  
│                                                              │  
│  LOGIN SHELL (e.g., SSH)                                    │  
│  ─────────────────────                                      │  
│  1. /etc/profile        (system-wide)                       │  
│  2. ~/.bash_profile  ─┐                                     │  
│  3. ~/.bash_login    ─┼─ First one found is read            │  
│  4. ~/.profile       ─┘                                     │  
│                                                              │  
│  Put here: Environment variables, PATH                       │  
│                                                              │  
├─────────────────────────────────────────────────────────────┤  
│                                                              │  
│  INTERACTIVE NON-LOGIN SHELL (e.g., new terminal tab)       │  
│  ─────────────────────────────────────────────────────────  │  
│  ~/.bashrc                                                   │  
│                                                              │  
│  Put here: Aliases, functions, prompt (PS1)                 │  
│                                                              │  
├─────────────────────────────────────────────────────────────┤  
│                                                              │  
│  PRO TIP: Add this to ~/.bash_profile:                      │  
│                                                              │  
│  if [[ -f ~/.bashrc ]]; then                                │  
│      source ~/.bashrc                                        │  
│  fi                                                          │  
│                                                              │  
│  This ensures aliases work in login shells too!             │  
│                                                              │  
└─────────────────────────────────────────────────────────────┘
```
