# Bash Configuration & Package Management

---

## Understanding Bash Configuration Files

### What are Configuration Files and Why Do They Exist?

When you open a terminal in Linux, you are starting a program called a **shell**. The shell is your CLI (command line interface) — it reads what you type, interprets it, and tells the OS what to do. **BASH** (Bourne Again SHell) is the most common shell on Linux systems.

But here's the thing: every time you start a new terminal session, Bash starts fresh. It will not remember your preferences, shortcuts, or customizations from before. This is where configuration files come into play.

**Configuration files** are special text files that Bash automatically reads when it starts. They contain instructions that customize your shell environment, such as:

- What your prompt looks like
- Shortcuts (aliases) for commands you use frequently
- Where to find programs (your PATH)
- Environment variables that programs need

Without configuration files, you'd have to manually set up your preferred settings every time you open a terminal — a hassle and time-consuming. Configuration files make your customizations *persistent*, meaning they survive across sessions.

---

### Interactive vs. Non-Interactive Shells

Before understanding which configuration file does what, we need to know how Bash can be started.

#### Interactive Shell

An **interactive shell** relies on the user to type commands and see output. You see a prompt, type something, press Enter, and something happens.

**Examples:**
- Opening a terminal app on your desktop
- SSH-ing into a remote server
- Running `bash` from within another shell

**Features enabled in interactive mode:**
- Command prompt (the `$` or `#` you see)
- Command history
- Tab completion
- Job control (`Ctrl+Z` to suspend)

#### Non-Interactive Shell

A **non-interactive shell** runs without user interaction. It executes commands from a script then exits.

**Example:**
```bash
bash myscript.sh
```

The script runs, does its job, then the shell exits. No prompt, no waiting for input.

> **Why This Distinction Matters:** Bash loads different config files depending on whether the shell is interactive or non-interactive. If you put your shortcuts in the wrong file, they won't be available when you need them.

---

### Login Shell vs. Non-Login Shell

There's another important distinction: **login** vs. **non-login** shells.

#### Login Shell

A login shell is the first shell that starts when you log into a system. Its main purpose is setting up the entire environment.

**Examples:**
- SSH-ing into a server
- Logging in at a physical console
- Using `su - username` (the `-` makes it a login shell)

#### Non-Login Shell

A non-login shell starts **after** you've already logged in. It uses the environment from its parent process and doesn't need to set everything up from scratch.

**Examples:**
- Opening a new terminal tab
- Running `bash` from within an existing shell
- Running a script

---

## The Configuration Files Explained

### `/etc/profile` (System-Wide)

| Attribute | Description |
|-----------|-------------|
| **What is it** | System-wide configuration that applies to ALL users |
| **When it's read** | When a user starts a login shell |
| **Who edits it** | System administrators (requires root privileges) |
| **Contents** | System-wide environment variables, PATH additions for everyone |

> ⚠️ **Warning:** Do NOT edit this file unless you're a sysadmin and know what you're doing. Changes affect all users.

---

### `~/.bash_profile` and `~/.profile`

| Attribute | Description |
|-----------|-------------|
| **What they are** | User-specific config files for **login shells** |
| **When they're read** | When the user starts a login shell (like SSH-ing into a server) |

**Reading order:**
1. `/etc/profile` (system-wide, always first)
2. `~/.bash_profile` (if it exists, Bash stops here)
3. `~/.bash_login` (only if `~/.bash_profile` doesn't exist)
4. `~/.profile` (only if neither of the above exist)

Bash only reads ONE of these user files — the first one it finds.

**What goes here:**
- Environment variables (like `EDITOR`, `LANG`)
- PATH modifications
- Anything that should be set once at login and inherited by all programs

**Example `~/.profile`:**
```bash
# Set default text editor
export EDITOR="nano"

# Add local bin directory to PATH
if [[ -d "$HOME/.local/bin" ]]; then
    PATH="$HOME/.local/bin:$PATH"
fi
```

---

### `~/.bashrc`

| Attribute | Description |
|-----------|-------------|
| **What it is** | User config for interactive (non-login) shells |
| **When it's read** | Every time you start an interactive non-login shell |

**What goes here:**
- Shortcuts (aliases)
- Shell functions
- Prompt customizations

**Example `~/.bashrc`:**
```bash
# Aliases
alias ll='ls -la'
alias gs='git status'

# Colorful prompt
PS1='\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\$ '
```

> **Important:** When you SSH into a server, you start a login shell. Login shells read `~/.profile` or `~/.bash_profile`, but NOT `~/.bashrc` by default!

**The Solution:** Add this to your `~/.bash_profile` or `~/.profile`:
```bash
# Source .bashrc if it exists
if [[ -f ~/.bashrc ]]; then
    source ~/.bashrc
fi
```

This ensures your aliases and prompt work even in login shells.

---

### Quick Reference: What Goes Where?

| Setting Type | File | Why |
|--------------|------|-----|
| Environment variables (`EDITOR`, `LANG`) | `~/.profile` or `~/.bash_profile` | Set once at login, inherited by all programs |
| PATH modifications | `~/.profile` or `~/.bash_profile` | Programs need to find executables |
| Aliases | `~/.bashrc` | Only needed in interactive shells |
| Shell functions | `~/.bashrc` | Only needed in interactive shells |
| Prompt (PS1) | `~/.bashrc` | Only needed in interactive shells |

**Rule of Thumb:**
- **Affects all programs?** → `~/.profile` or `~/.bash_profile`
- **Only affects your command line?** → `~/.bashrc`

---

### Applying Changes

After editing a config file, changes don't take effect immediately. You have two options:

**Option 1: Source the file**
```bash
source ~/.bashrc
# or equivalently:
. ~/.bashrc
```
This reads and executes the file in your *current* shell. Changes take effect immediately.

**Option 2: Start a new shell**
```bash
bash
```
Or simply open a new terminal window/tab.

---

## Customizing Your Bash Prompt

### What is the Prompt?

The **prompt** is the text or symbol that appears at the beginning of the line where you type commands. It acts as a "waiting" indicator.

**Default Debian prompt:**
```
root@username:~#
```

**Breakdown:**
| Component | Meaning |
|-----------|---------|
| `root` | The username (who you're logged in as) |
| `@` | Separator (decoration) |
| `username` | The hostname (computer's name) |
| `:` | Separator |
| `~` | Current directory (`~` = home directory) |
| `#` | Root user indicator (`$` for regular users) |

---

### The PS1 Variable

The prompt is controlled by the **`PS1`** (Prompt String 1) environment variable.

**View your current prompt:**
```bash
echo "$PS1"
```

**Sample output:**
```
\u@\h:\w\$
```

| Escape Code | Meaning |
|-------------|---------|
| `\u` | Username of current user |
| `@` | Literal @ symbol |
| `\h` | Hostname (computer name) |
| `:` | Literal colon |
| `\w` | Working directory (full path) |
| `\$` | `$` for regular users, `#` for root |

**Change your prompt temporarily:**
```bash
PS1="> "
```
Now your prompt is just `>`. This lasts only until you close the terminal.

---

### Prompt Escape Sequences

| Sequence | Meaning | Example Output |
|----------|---------|----------------|
| `\u` | Username | `alice` |
| `\h` | Hostname (short) | `laptop` |
| `\H` | Hostname (full) | `laptop.local` |
| `\w` | Current directory (full path, `~` for home) | `~/projects/myapp` |
| `\W` | Current directory (base name only) | `myapp` |
| `\$` | `$` for regular users, `#` for root | `$` |
| `\n` | Newline | *(starts a new line)* |
| `\t` | Time (24-hour HH:MM:SS) | `14:30:45` |
| `\d` | Date (Day Month Date) | `Mon Jan 15` |
| `\!` | History number of this command | `142` |

**Practical Examples:**

```bash
# Simple username and directory
PS1="\u:\w \$ "
# Result: dan:~/projects $

# Include hostname (useful for SSH)
PS1="\u@\h:\w \$ "
# Result: dan@webserver:~/projects $

# Two-line prompt (for long paths)
PS1="\u@\h:\w\n\$ "
# Result:
# dan@webserver:~/very/long/path/to/project
# $
```

---

### Adding Colors to Your Prompt

Colors make prompts easier to read and can highlight important information.

#### ANSI Color Code Format
```
\[\e[0;32m\]
```

| Component | Meaning |
|-----------|---------|
| `\[` and `\]` | Tell Bash the code has "zero width" (prevents cursor misalignment) |
| `\e[` | Starts the escape sequence |
| `0;32` | Style;Color (`0` = normal, `32` = green) |
| `m` | Ends the color sequence |

#### Text Colors

| Color | Code | Bright Version |
|-------|------|----------------|
| Black | 30 | 90 |
| Red | 31 | 91 |
| Green | 32 | 92 |
| Yellow | 33 | 93 |
| Blue | 34 | 94 |
| Magenta | 35 | 95 |
| Cyan | 36 | 96 |
| White | 37 | 97 |

#### Styles

| Style | Code |
|-------|------|
| Reset (normal) | 0 |
| Bold | 1 |
| Dim | 2 |
| Underline | 4 |

> ⚠️ **Critical:** Always end your prompt with the reset code `\[\e[0m\]` — otherwise everything you type will be colored too!

**Color Examples:**
```bash
# Green username, blue directory
PS1='\[\e[32m\]\u\[\e[0m\]@\h:\[\e[34m\]\w\[\e[0m\]\$ '

# Red prompt for root (warning!)
PS1='\[\e[31m\]\u@\h:\w\$ \[\e[0m\]'
```

---

### Making Your Prompt Permanent

Add your PS1 definition to `~/.bashrc`:
```bash
# Add to ~/.bashrc
PS1='\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\$ '
```

Then reload:
```bash
source ~/.bashrc
```

---

### Other Prompt Variables

| Variable | When It's Shown |
|----------|-----------------|
| `PS0` | After you hit Enter but before the command's result shows |
| `PS1` | Primary prompt (main one you customize) |
| `PS2` | Continuation prompt (when command spans multiple lines) |
| `PS3` | Used in shell scripts with `select` command for menus |
| `PS4` | Used when debugging scripts (`set -x` or `bash -x`) |

**Examples:**

```bash
# PS0 - Shows timestamp before command runs
PS0='[Command started at \t]\n'

# PS2 - Default is ">"
# Appears when you have an incomplete command:
# $ echo "This is a very
# > long sentence"

# PS3 - Menu prompt in select statements
# Default is "#?"

# PS4 - Debug prefix
# Default is "+"
```

---

## Aliases and Shell Functions

### What are Aliases?

An **alias** is a shortcut — a short name that expands into a longer command.

**Syntax:**
```bash
alias name='command'
```

**Rules:**
- No spaces around the `=`
- Use quotes if the command contains spaces or special characters

**Examples:**
```bash
alias ll='ls -la'
alias gs='git status'
alias update='sudo apt update && sudo apt upgrade'
```

**Managing Aliases:**
```bash
# View all aliases
alias

# Check what an alias expands to
type ll
# Output: ll is aliased to 'ls -la'

# Temporarily bypass an alias
\ls              # Method 1: Backslash
/bin/ls          # Method 2: Full path
unalias ll       # Method 3: Remove alias
```

#### Alias Limitations

Aliases are simple text substitution. They:
- ✅ Replace the alias name with command text
- ❌ Cannot accept arguments in the middle
- ❌ Cannot contain logic (if/else)

For anything more complex, use **shell functions**.

---

### Shell Functions

A shell function is like a mini script that lives in your shell. Unlike aliases, functions:
- Can accept arguments (`$1`, `$2`, etc.)
- Can contain logic (if/else, loops)
- Can have multiple commands
- Can return exit codes

**Basic Syntax:**
```bash
function_name() {
    commands
}
```

**Example 1: Create directory and cd into it**
```bash
mkd() {
    mkdir -p "$1" && cd "$1"
}
```

Usage:
```bash
$ mkd new_project
$ pwd
/home/alice/new_project
```

**Example 2: Extract various archive formats**
```bash
extract() {
    if [[ ! -f "$1" ]]; then
        echo "Error: '$1' is not a file"
        return 1
    fi

    case "$1" in
        *.tar.gz)  tar -xzf "$1" ;;
        *.tar.bz2) tar -xjf "$1" ;;
        *.tar)     tar -xf "$1" ;;
        *.zip)     unzip "$1" ;;
        *.gz)      gunzip "$1" ;;
        *)         echo "Unknown format: $1" ;;
    esac
}
```

---

### Making Aliases and Functions Permanent

Add them to `~/.bashrc`:
```bash
# ~/.bashrc

# Aliases
alias ll='ls -la'
alias gs='git status'
alias ..='cd ..'
alias ...='cd ../..'

# Functions
mkd() {
    mkdir -p "$1" && cd "$1"
}
```

Reload:
```bash
source ~/.bashrc
```

---

### Useful Alias Ideas

```bash
# Safety aliases (ask before overwriting)
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'

# Colorized output
alias ls='ls --color=auto'
alias grep='grep --color=auto'

# Quick navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ~='cd ~'

# Git shortcuts
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline'
```

> ⚠️ **Warning about `rm`:** Aliasing `rm` to `rm -i` can create a false sense of security. If you use a system without your aliases, you might accidentally delete files expecting a confirmation that never comes.

---

## The PATH Environment Variable

### What is PATH?

**PATH** is an environment variable that tells your shell where to look for executable programs.

**View your PATH:**
```bash
echo $PATH
```

**Sample output:**
```
/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
```

Directories are separated by colons (`:`). The shell searches them **in order, left to right**.

### How PATH Works

When you type `ls`:
1. Shell checks: Is `ls` in `/usr/local/bin`? NO
2. Shell checks: Is `ls` in `/usr/bin`? YES! Run it.

If not found anywhere: `bash: somecommand: command not found`

---

### Adding a Directory to PATH

**Why would you do this?**
- You installed software in a non-standard location
- You have personal scripts in `~/bin` or `~/.local/bin`
- A programming language installed tools in its own directory

**Temporary Addition (current session only):**
```bash
PATH="$HOME/.local/bin:$PATH"
```

**Permanent Addition** — add to `~/.profile` or `~/.bash_profile`:
```bash
# Add .local/bin to PATH if it exists
if [[ -d "$HOME/.local/bin" ]]; then
    PATH="$HOME/.local/bin:$PATH"
fi
```

---

### Common PATH Mistakes

**Mistake 1: Overwriting PATH entirely**
```bash
# WRONG - destroys your existing PATH!
PATH="/my/custom/bin"

# CORRECT
PATH="/my/custom/bin:$PATH"
```

**Mistake 2: Forgetting to export**
```bash
# For child processes to see PATH changes in scripts:
export PATH="$HOME/bin:$PATH"
```

---

## Package Management with APT

### What is a Package Manager?

A **package manager** installs, updates, and removes software on your system, automating what used to be a tedious manual process.

### Key Concepts

| Concept | Description |
|---------|-------------|
| **Package** | A bundle containing software, metadata, dependency info, and installation instructions. Debian uses `.deb` format. |
| **Repository** | A server hosting packages (like an app store for your OS) |
| **Dependency** | Software that another package requires to function |

**Debian Repository Branches:**
- **Stable** — Rigorously tested, rarely changes. Best for servers.
- **Testing** — Newer packages being prepared for stable.
- **Unstable (sid)** — Cutting edge, may break.

---

### dpkg vs. APT

| Tool | Level | Dependencies | Use Case |
|------|-------|--------------|----------|
| `dpkg` | Low-level | Manual | Individual `.deb` files |
| `apt` | High-level | Automatic | 99% of package management |

---

### Essential APT Commands

| Command | Description |
|---------|-------------|
| `sudo apt update` | Refresh package lists from repositories |
| `sudo apt upgrade` | Upgrade all packages (safe, no removals) |
| `sudo apt full-upgrade` | Upgrade all packages (may remove some) |
| `sudo apt install foo` | Install package "foo" |
| `sudo apt remove foo` | Remove "foo" (keep config files) |
| `sudo apt purge foo` | Remove "foo" and its config files |
| `sudo apt autoremove` | Remove unneeded dependencies |
| `apt search regex` | Search for packages |
| `apt show foo` | Display package details |
| `apt list --manual-installed` | List manually installed packages |
| `apt clean` | Delete all cached package files |
| `apt autoclean` | Delete outdated cached package files |

**The Update + Upgrade Combo:**
```bash
sudo apt update && sudo apt upgrade
```

---

### Warnings and Best Practices

> ⚠️ Always use `sudo` with APT commands that modify the system.

> ⚠️ Update regularly — falling behind can make upgrades more complex.

> ⚠️ Read what APT tells you before confirming installs/upgrades.

> ⚠️ Be careful with `full-upgrade` — it can remove packages.

---

### `apt` vs `apt-get`

| Tool | Best For | Notes |
|------|----------|-------|
| `apt` | Interactive use | Newer, user-friendly, has progress bar |
| `apt-get` | Scripts | Older, more stable output format |

---

## Summary: Configuration File Cheat Sheet

```
┌─────────────────────────────────────────────────────────────┐
│                    BASH STARTUP FILES                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  LOGIN SHELL (e.g., SSH)                                    │
│  ─────────────────────                                      │
│  1. /etc/profile        (system-wide)                       │
│  2. ~/.bash_profile  ─┐                                     │
│  3. ~/.bash_login    ─┼─ First one found is read            │
│  4. ~/.profile       ─┘                                     │
│                                                             │
│  Put here: Environment variables, PATH                      │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  INTERACTIVE NON-LOGIN SHELL (e.g., new terminal tab)       │
│  ─────────────────────────────────────────────────────────  │
│  ~/.bashrc                                                  │
│                                                             │
│  Put here: Aliases, functions, prompt (PS1)                 │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PRO TIP: Add this to ~/.bash_profile:                      │
│                                                             │
│  if [[ -f ~/.bashrc ]]; then                                │
│      source ~/.bashrc                                       │
│  fi                                                         │
│                                                             │
│  This ensures aliases work in login shells too!             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```
